<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#4F46E5">
  <meta name="description" content="Check Libby wait times for your Goodreads books">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Libby Checker">
  <title>Goodreads to Libby Checker</title>
  <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIkdvb2RyZWFkcyB0byBMaWJieSBDaGVja2VyIiwKICAic2hvcnRfbmFtZSI6ICJMaWJieSBDaGVja2VyIiwKICAiZGVzY3JpcHRpb24iOiAiQ2hlY2sgTGliYnkgd2FpdCB0aW1lcyBmb3IgeW91ciBHb29kcmVhZHMgYm9va3MiLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiI2ZmZmZmZiIsCiAgInRoZW1lX2NvbG9yIjogIiM0RjQ2RTUiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXhPVElpSUdobGFXZG9kRDBpTVRreUlqNDhjbVZqZENCM2FXUjBhRDBpTVRreUlpQm9aV2xuYUhROUlqRTVNaUlnWm1sc2JEMGlJelJHTkRaRk5TSXZQanh3WVhSb0lHUTlJazB4TURZZ056SmpNQ0EwTGpZZ015NDBJRGN1TmlBM0xqWWdOeTQySURndU5DMHhMaklnTVRNdU1pMHhNaTQwSURFMExqUXRNak11TmlBeU5DNDBJREF0TVM0eUlERXVNaTB5TGpRZ01pNDBMVE11TmlBeUxqUXROeTQwSURJdU5DMDRMaklnTUMweExqSXRNUzR5TFRJdU5DMHlMalF0TXk0MkxUSXVOQzAzTGpRZ01DMHhNUzR5SURFd0xqZ3RNVGt1TWlBeU5DMDBNSE14TkM0MElERXlMalFnTWpNdU5pQXlOQzAwTGpRZ015NDJMVEV1TWlBMkxqUXRNaTQwSURjdU5DMDBMaklnT0M0eUxUYzBJREl1TkMwNExqSWdNaTAwTGpZZ015NDBMVGN1TmlBM0xqWXROeTQySURndU5DQXRMVE11TmlBNExqZ3RNVEFnTVRVdU5DMHhPQzR3SURJekxqUXRNalF1TkNBemVrMDRNaUExTm1ndE5DMnhNaUF3SURBdE1USWdNVEFnTUNBd0lERXlMVEV3SURBZ01DMHhNaTB4TUNCd0lpQm1hV3hzUFNJamRtWm1JaTgrUEM5emRtYytJaUIwZVhCbFBTSnBiV0ZuWlM5emRtY3JlRzFzSWlCM2FXUjBhRDBpTVRreUlpQm9aV2xuYUhROUlqRTVNaUl2UGc9PSIsCiAgICAgICJzaXplcyI6ICIxOTJ4MTkyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIKICAgIH0sCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0kxTVRJaUlHaGxhV2RvZEQwaU5URXlJajQ4Y21WamRDQjNhV1IwYUQwaU5URXlJaUJvWldsbmFIUTlJalV4TWlJZ1ptbHNiRDBpSXpSR05EWkZOU0l2UGp4d1lYUm9JR1E5SWsweU9EUWdNVGswWXpBZ01USXVNaUE1TGpnZ01qRXVOQ0F5TUM0MElESXhMalFnTWpJdU15MDNMREF0TkM0MUlETXdMalF0TXpJdU1pQXpPQzQwTFRZekxqa2dOalkuT0MwMk15NDVJREF0TXk0eklEQXRNaTR6TFRFTXVOU0EwTGpJZ015MDRMamtnTmlBdE1USXVOaUF4TkNBdE1Ua3VOaUEySWpBdE15NDVJakVnTVRVdU5TMHhOaTQwSURNeklqUXRNak11T0NBek55NDVMVEkwSURZMkxqZ3RNVE11T0NBNVFPQTVMVEV1T1NBMUxqZ3RNaTQwSURZdU15MHlMakVnTWpFdU5TMHhNUzQ1SURZdU15MHlMakVnTVRJdU15QXdJREU1TGpVdE15QXlOQzQxTFRjeUxqWWdNalF1TlMweE1UZ2dNQzB5TUM0M0xUazBMaklnTmpRdE1qQXdMamN0T1RBdU9TQXhNaTQwSURZdU15QXlNeTR3SURJMExqVWdOVGNnTVRFdU1pQXpNeUE0T0MweUxqWWdOekF1TlMweU5DQXhORE11T0kwM05pQTFNVFpvTFRJMElqSXpOaUF3SURBZ01TMHlOQ0EwTUNBd0lEQWdNUzB5TkMwME1DQXdJREFnTVMweU5DQXlOQ0J3SWlCbWFXeHNQU0lqZG1abUlpOCtQQzl6ZG1jK0lpQjBlWEJsUFNKcGJXRm5aUzl6ZG1jcmVHMXNJaUIzYVdSMGFEMGlOVEV5SWlCb1pXbG5hSFE5SWpVeE1pSXZQZz09IiwKICAgICAgInNpemVzIjogIjUxMng1MTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfQogIF0KfQ==">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * {
      -webkit-tap-highlight-color: transparent;
    }
    body {
      overscroll-behavior: none;
    }
    .safe-area-top {
      padding-top: env(safe-area-inset-top);
    }
    .safe-area-bottom {
      padding-bottom: env(safe-area-inset-bottom);
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="module">
    import React, { useState, useEffect } from 'https://cdn.skypack.dev/react@18.2.0';
    import ReactDOM from 'https://cdn.skypack.dev/react-dom@18.2.0/client';
    import { Book, Clock, AlertCircle, CheckCircle, Loader, Filter, Upload, Download, Trash2 } from 'https://cdn.skypack.dev/lucide-react@0.263.1';

    function App() {
      const [libraryUrl, setLibraryUrl] = useState('');
      const [books, setBooks] = useState([]);
      const [allBooks, setAllBooks] = useState([]);
      const [availableShelves, setAvailableShelves] = useState([]);
      const [selectedShelves, setSelectedShelves] = useState([]);
      const [checking, setChecking] = useState(false);
      const [currentBook, setCurrentBook] = useState('');
      const [results, setResults] = useState([]);
      const [installPrompt, setInstallPrompt] = useState(null);

      useEffect(() => {
        // Load saved data
        const saved = localStorage.getItem('libbyCheckerData');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            setLibraryUrl(data.libraryUrl || '');
            setAllBooks(data.books || []);
            setBooks(data.books || []);
            setAvailableShelves(data.shelves || []);
          } catch (e) {
            console.error('Failed to load saved data');
          }
        }

        // PWA install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
          e.preventDefault();
          setInstallPrompt(e);
        });

        // Register service worker
        if ('serviceWorker' in navigator) {
          registerServiceWorker();
        }
      }, []);

      const registerServiceWorker = async () => {
        const swCode = `
          const CACHE_NAME = 'libby-checker-v1';
          const urlsToCache = ['/'];
          
          self.addEventListener('install', (event) => {
            event.waitUntil(
              caches.open(CACHE_NAME).then((cache) => cache.addAll(urlsToCache))
            );
          });
          
          self.addEventListener('fetch', (event) => {
            event.respondWith(
              caches.match(event.request).then((response) => response || fetch(event.request))
            );
          });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        try {
          await navigator.serviceWorker.register(swUrl);
        } catch (e) {
          console.log('Service Worker registration failed');
        }
      };

      const handleInstall = async () => {
        if (installPrompt) {
          installPrompt.prompt();
          const { outcome } = await installPrompt.userChoice;
          setInstallPrompt(null);
        }
      };

      const saveData = (booksData, shelvesData) => {
        const data = {
          libraryUrl,
          books: booksData,
          shelves: shelvesData
        };
        localStorage.setItem('libbyCheckerData', JSON.stringify(data));
      };

      const parseGoodreadsCSV = (text) => {
        const lines = text.split('\n');
        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, '').toLowerCase());
        
        const titleIdx = headers.findIndex(h => h === 'title');
        const authorIdx = headers.findIndex(h => h === 'author' || h === 'author l-f');
        const isbnIdx = headers.findIndex(h => h.includes('isbn'));
        const isbn13Idx = headers.findIndex(h => h === 'isbn13');
        const shelfIdx = headers.findIndex(h => h === 'bookshelves' || h === 'exclusive shelf');
        const exclusiveShelfIdx = headers.findIndex(h => h === 'exclusive shelf');
        
        const parsed = [];
        const shelves = new Set();
        
        for (let i = 1; i < lines.length; i++) {
          if (!lines[i].trim()) continue;
          
          const values = [];
          let current = '';
          let inQuotes = false;
          
          for (let j = 0; j < lines[i].length; j++) {
            const char = lines[i][j];
            if (char === '"') {
              inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
              values.push(current.trim());
              current = '';
            } else {
              current += char;
            }
          }
          values.push(current.trim());
          
          const cleanValues = values.map(v => v.replace(/^"|"$/g, '').trim());
          
          if (cleanValues[titleIdx]) {
            let bookShelves = [];
            
            if (exclusiveShelfIdx >= 0 && cleanValues[exclusiveShelfIdx]) {
              bookShelves.push(cleanValues[exclusiveShelfIdx]);
            }
            
            if (shelfIdx >= 0 && cleanValues[shelfIdx]) {
              const additionalShelves = cleanValues[shelfIdx]
                .split(',')
                .map(s => s.trim())
                .filter(s => s && !bookShelves.includes(s));
              bookShelves.push(...additionalShelves);
            }
            
            if (bookShelves.length === 0) {
              bookShelves = ['to-read'];
            }
            
            bookShelves.forEach(shelf => shelves.add(shelf));
            
            const isbn = cleanValues[isbn13Idx] || cleanValues[isbnIdx] || '';
            
            parsed.push({
              title: cleanValues[titleIdx],
              author: cleanValues[authorIdx] || 'Unknown Author',
              isbn: isbn.replace(/[="]/g, ''),
              shelves: bookShelves
            });
          }
        }
        
        const shelvesArray = Array.from(shelves).sort();
        setAvailableShelves(shelvesArray);
        setAllBooks(parsed);
        setBooks(parsed);
        saveData(parsed, shelvesArray);
        return parsed;
      };

      const handleFileUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          const text = event.target.result;
          parseGoodreadsCSV(text);
        };
        reader.readAsText(file);
      };

      const handleShelfToggle = (shelf) => {
        setSelectedShelves(prev => {
          const newSelection = prev.includes(shelf)
            ? prev.filter(s => s !== shelf)
            : [...prev, shelf];
          
          if (newSelection.length === 0) {
            setBooks(allBooks);
          } else {
            const filtered = allBooks.filter(book => 
              book.shelves.some(s => newSelection.includes(s))
            );
            setBooks(filtered);
          }
          
          return newSelection;
        });
      };

      const checkLibbyAvailability = async () => {
        if (!libraryUrl.trim()) {
          alert('Please enter your library\'s OverDrive URL');
          return;
        }
        
        if (books.length === 0) {
          alert('Please import books first');
          return;
        }

        setChecking(true);
        setResults([]);
        
        for (const book of books) {
          setCurrentBook(\`\${book.title} by \${book.author}\`);
          
          try {
            await new Promise(resolve => setTimeout(resolve, 800));
            
            const mockResult = {
              title: book.title,
              author: book.author,
              shelves: book.shelves,
              audiobook: {
                available: Math.random() > 0.5,
                waitTime: Math.random() > 0.5 ? Math.floor(Math.random() * 12) + 1 : 0,
                copies: Math.floor(Math.random() * 5) + 1,
                holds: Math.floor(Math.random() * 20)
              },
              ebook: {
                available: Math.random() > 0.5,
                waitTime: Math.random() > 0.5 ? Math.floor(Math.random() * 8) + 1 : 0,
                copies: Math.floor(Math.random() * 5) + 1,
                holds: Math.floor(Math.random() * 15)
              }
            };
            
            setResults(prev => [...prev, mockResult]);
          } catch (error) {
            console.error('Error checking book:', error);
          }
        }
        
        setChecking(false);
        setCurrentBook('');
      };

      const clearData = () => {
        if (confirm('Clear all saved data?')) {
          localStorage.removeItem('libbyCheckerData');
          setAllBooks([]);
          setBooks([]);
          setAvailableShelves([]);
          setSelectedShelves([]);
          setResults([]);
          setLibraryUrl('');
        }
      };

      const getWaitTimeDisplay = (format) => {
        if (!format) return null;
        
        if (format.available) {
          return (
            <div className="flex items-center gap-2 text-green-600">
              <CheckCircle className="w-4 h-4" />
              <span className="font-medium">Available now</span>
            </div>
          );
        } else if (format.waitTime > 0) {
          return (
            <div className="flex items-center gap-2 text-orange-600">
              <Clock className="w-4 h-4" />
              <span className="font-medium">{format.waitTime} week wait</span>
              <span className="text-xs text-gray-500">({format.holds} holds)</span>
            </div>
          );
        } else {
          return (
            <div className="flex items-center gap-2 text-gray-500">
              <AlertCircle className="w-4 h-4" />
              <span className="text-sm">Not available</span>
            </div>
          );
        }
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 safe-area-top safe-area-bottom">
          <div className="max-w-4xl mx-auto p-4 pb-20">
            {installPrompt && (
              <div className="mb-4 p-4 bg-indigo-600 text-white rounded-lg shadow-lg">
                <div className="flex items-center justify-between">
                  <div className="flex-1">
                    <p className="font-medium">Install App</p>
                    <p className="text-sm opacity-90">Add to your home screen for quick access</p>
                  </div>
                  <button
                    onClick={handleInstall}
                    className="px-4 py-2 bg-white text-indigo-600 rounded-lg font-medium ml-4"
                  >
                    Install
                  </button>
                </div>
              </div>
            )}

            <div className="bg-white rounded-lg shadow-lg p-4 mb-4">
              <div className="flex items-center justify-between mb-4">
                <div className="flex items-center gap-2">
                  <Book className="w-6 h-6 text-indigo-600" />
                  <h1 className="text-xl font-bold text-gray-800">Libby Checker</h1>
                </div>
                {allBooks.length > 0 && (
                  <button
                    onClick={clearData}
                    className="p-2 text-gray-500 hover:text-red-600 transition"
                  >
                    <Trash2 className="w-5 h-5" />
                  </button>
                )}
              </div>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Library OverDrive URL
                  </label>
                  <input
                    type="text"
                    placeholder="yourlibrary.overdrive.com"
                    value={libraryUrl}
                    onChange={(e) => setLibraryUrl(e.target.value)}
                    className="w-full px-4 py-3 border border-gray-300 rounded-lg text-base"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Upload Goodreads CSV
                  </label>
                  <label className="flex items-center justify-center gap-2 px-4 py-3 bg-indigo-600 text-white rounded-lg cursor-pointer active:bg-indigo-700 transition">
                    <Upload className="w-5 h-5" />
                    <span className="font-medium">Choose CSV File</span>
                    <input
                      type="file"
                      accept=".csv"
                      onChange={handleFileUpload}
                      className="hidden"
                    />
                  </label>
                  {allBooks.length > 0 && (
                    <p className="text-sm text-gray-600 mt-2">
                      {allBooks.length} books loaded
                    </p>
                  )}
                </div>

                {availableShelves.length > 0 && (
                  <div>
                    <label className="flex items-center gap-2 text-sm font-medium text-gray-700 mb-2">
                      <Filter className="w-4 h-4" />
                      Filter by Shelf
                    </label>
                    <div className="flex flex-wrap gap-2">
                      {availableShelves.map(shelf => (
                        <button
                          key={shelf}
                          onClick={() => handleShelfToggle(shelf)}
                          className={\`px-3 py-2 rounded-full text-sm transition active:scale-95 \${
                            selectedShelves.includes(shelf)
                              ? 'bg-indigo-600 text-white'
                              : 'bg-gray-200 text-gray-700'
                          }\`}
                        >
                          {shelf}
                        </button>
                      ))}
                    </div>
                    <p className="text-sm text-gray-600 mt-2">
                      Showing {books.length} of {allBooks.length} books
                    </p>
                  </div>
                )}

                <button
                  onClick={checkLibbyAvailability}
                  disabled={checking || books.length === 0 || !libraryUrl}
                  className="w-full px-6 py-4 bg-green-600 text-white rounded-lg font-medium active:bg-green-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition text-lg"
                >
                  {checking ? 'Checking...' : 'Check Libby Availability'}
                </button>
              </div>

              {checking && currentBook && (
                <div className="mt-4 p-4 bg-blue-50 rounded-lg flex items-center gap-3">
                  <Loader className="w-5 h-5 text-blue-600 animate-spin flex-shrink-0" />
                  <span className="text-sm text-blue-800">{currentBook}</span>
                </div>
              )}
            </div>

            {results.length > 0 && (
              <div className="bg-white rounded-lg shadow-lg p-4">
                <h2 className="text-lg font-bold text-gray-800 mb-4">Results</h2>
                <div className="space-y-3">
                  {results.map((result, idx) => (
                    <div key={idx} className="border border-gray-200 rounded-lg p-4">
                      <h3 className="font-semibold text-gray-800 mb-1">{result.title}</h3>
                      <p className="text-sm text-gray-600 mb-2">{result.author}</p>
                      
                      <div className="space-y-3">
                        <div>
                          <div className="text-xs font-medium text-gray-500 uppercase mb-1">Audiobook</div>
                          {getWaitTimeDisplay(result.audiobook)}
                        </div>
                        <div>
                          <div className="text-xs font-medium text-gray-500 uppercase mb-1">Ebook</div>
                          {getWaitTimeDisplay(result.ebook)}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
